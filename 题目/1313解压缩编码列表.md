* [题目: 1313 解压缩编码列表](#%E9%A2%98%E7%9B%AE-1313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8)
  * [题目说明](#%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E)
  * [示例](#%E7%A4%BA%E4%BE%8B)
  * [解题](#%E8%A7%A3%E9%A2%98)
    * [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
    * [题解](#%E9%A2%98%E8%A7%A3)



# 题目: 1313 解压缩编码列表



## 题目说明

> 给你一个以行程长度编码压缩的整数列表 nums 。
>
> 考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。
>
> 请你返回解压后的列表。
>
> 



## 示例



```
输入：nums = [1,2,3,4]
输出：[2,4,4,4]
解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。

```



## 解题



### 解题思路

* 首先是分别提取出每一组的数字出现次数和数字
* 然后使用append动态增加切片的方式进行结果生成



***

### 题解

```go
func decompressRLElist(nums []int) []int {
    var result []int 
    n:= len(nums)
    for i:=0 ;i< n/2;i++{
        freq,val := nums[i*2],nums[i*2+1]
        for j:=0 ;j< freq;j++{
            result=append(result,val)
        }
    }
    return result
}
```

